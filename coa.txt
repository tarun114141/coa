//Scan line

#include<GL/glut.h>


void InitF(){
    glClearColor(0,0,0,1);
    gluOrtho2D(0,500,0,500);



}


void draw_pixel(int x, int y){
     glColor3f(0.0, 1.0, 1.0);
     glPointSize(1.0);
     glBegin(GL_POINTS);
     glVertex2i(x, y);
     glEnd();

}

void draw_triangle(){
    glClear(GL_COLOR_BUFFER_BIT);
    glPointSize(3);
    glColor3f(1.0,1.0,0.2);
    glBegin(GL_LINE_STRIP);
    glVertex2i(100,100);
    glVertex2i(400,100);
    glVertex2i(200,400);
    glVertex2i(100,100);
    glEnd();
}

void Edge(float x1, float y1, float x2, float y2, int *le, int *re){
    float temp, x, mx;
    int i;

    if(y1>y2){
        temp=x1;x1=x2;x2=temp;
        temp=y1;y1=y2;y2=temp;
    }

    if(y1==y2){
        mx=x2-x1;
    }else{
        mx=(x2-x1)/(y2-y1);
    }

    x=x1;

    for( i=(int)y1;i<=(int)y2;i++){
        if(x<=(float)le[i])  le[i]=(int)x;
    }
    if(x>(float)re[i])  re[i]= (int)x;

}


void scanLine(float x1, float y1, float x2, float y2, float x3, float y3){
    int le[500];
    int re[500];

    for(int i=0;i<500;i++){
        le[i]=500;
        re[i]=0;
    }

    Edge(x1,y1,x2,y2,le,re);
     Edge(x2,y2,x3,y3,le,re);
      Edge(x3,y3,x1,y1,le,re);

    for( int j=0;j<500;j++){
        if(le[j]<=re[j]){
            for(int i=le[j];i<=re[j];i++){
                draw_pixel(i,j);
            }
        }
    }




}

void display(){
    draw_triangle();
    scanLine(100,100,400,100,200,400);
    glFlush();

}


int main(int argc, char **argv){

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(500,500);
    glutInitWindowPosition(20,20);
    glutCreateWindow("scan line");
    InitF();
    glutDisplayFunc(display);
    glutMainLoop();

return 0;
}



//Flood fill


#include<GL/glut.h>


void InitF(){
    glClearColor(0,0,0,1);
    gluOrtho2D(0,500,0,500);



}


void draw_pixel(int x, int y){
     glColor3f(1.0, 1.0, 0.0);
     glPointSize(1.0);
     glBegin(GL_POINTS);
     glVertex2i(x, y);
     glEnd();

}

void draw_triangle(){
    glClear(GL_COLOR_BUFFER_BIT);
    glPointSize(5);
    glColor3f(1.0,1.0,0.7);
    glBegin(GL_LINE_STRIP);
    glVertex2i(100,100);
    glVertex2i(400,100);
    glVertex2i(200,400);
    glVertex2i(100,100);
    glEnd();
}

void getPixel(int x, int y, float color[3]){
    glReadPixels(x,y,1,1,GL_RGB,GL_FLOAT,color);
}

void setPixel(int x, int y, float color[3]){
    glBegin(GL_POINTS);
    glColor3fv(color);
    glVertex2i(x,y);
    glEnd();


}

void Flood(int x, int y, float fillColor[3], float oldColor[3]){
    float pixelColor[3];
    getPixel(x,y,pixelColor);
    if(pixelColor[0]==oldColor[0] &&
       pixelColor[1]==oldColor[1] &&
       pixelColor[2]==oldColor[2]){
        setPixel(x,y,fillColor);
        Flood(x + 1, y, fillColor, oldColor);
        Flood(x - 1, y, fillColor, oldColor);
        Flood(x, y + 1, fillColor, oldColor);
        Flood(x, y - 1, fillColor, oldColor);


       }
}

void display(){
    draw_triangle();
    float oldColor[3]={0,0,0};
    float fillColor[3]={1,0,0};
    Flood(200,200,fillColor,oldColor);


    glFlush();

}


int main(int argc, char **argv){

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(500,500);
    glutInitWindowPosition(20,20);
    glutCreateWindow("scan line");
    InitF();
    glutDisplayFunc(display);
    glutMainLoop();

return 0;
}







//Boundary Fill

#include <GL/glut.h>

int seedX = 150, seedY = 150;

void putPixel(int x, int y) {
    glBegin(GL_POINTS);
    glVertex2i(x, y);
    glEnd();
    glFlush();
}

void boundaryFill(int x, int y, float fillColor[3], float borderColor[3]) {
    unsigned char pixel[3];

    glReadPixels(x, y, 1, 1, GL_RGB, GL_UNSIGNED_BYTE, pixel);

    if ((pixel[0] != (unsigned char)(borderColor[0] * 255) ||
         pixel[1] != (unsigned char)(borderColor[1] * 255) ||
         pixel[2] != (unsigned char)(borderColor[2] * 255)) &&
        (pixel[0] != (unsigned char)(fillColor[0] * 255) ||
         pixel[1] != (unsigned char)(fillColor[1] * 255) ||
         pixel[2] != (unsigned char)(fillColor[2] * 255))) {

        glColor3fv(fillColor);
        putPixel(x, y);

        boundaryFill(x + 1, y, fillColor, borderColor);
        boundaryFill(x - 1, y, fillColor, borderColor);
        boundaryFill(x, y + 1, fillColor, borderColor);
        boundaryFill(x, y - 1, fillColor, borderColor);
    }
}

void drawPolygon() {
    glColor3f(0, 0, 0);

    glBegin(GL_LINE_LOOP);
        glVertex2i(100, 100);
        glVertex2i(300, 100);
        glVertex2i(300, 300);
        glVertex2i(100, 300);
    glEnd();
    glFlush();
}

void display() {
    glClear(GL_COLOR_BUFFER_BIT);

    drawPolygon();

    float fillColor[3] = {1, 0, 0};
    float borderColor[3] = {0, 0, 0};

    boundaryFill(seedX, seedY, fillColor, borderColor);

    glFlush();
}

void init() {
    glClearColor(1, 1, 1, 1);
    gluOrtho2D(0, 500, 0, 500);
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(500, 500);
    glutCreateWindow("Boundary Fill (Auto Start)");

    init();
    glutDisplayFunc(display);

    glutMainLoop();
    return 0;
}


// lineClipping


#include <GL/glut.h>
#define xmin 100
#define ymin 100
#define xmax 300
#define ymax 300
#define LEFT 1
#define RIGHT 2
#define BOTTOM 4
#define TOP 8
float x1p = 50, y1p = 50, x2p = 350, y2p = 350;
int computeCode(float x, float y) {
 int code = 0;
 if (x < xmin) code |= LEFT;
 else if (x > xmax) code |= RIGHT;
 if (y < ymin) code |= BOTTOM;
 else if (y > ymax) code |= TOP;
 return code;
}
void display() {
 glClear(GL_COLOR_BUFFER_BIT);
 float x1 = x1p, y1 = y1p;
 float x2 = x2p, y2 = y2p;
 int code1 = computeCode(x1, y1);
 int code2 = computeCode(x2, y2);
 int accept = 0;
 while (1) {
 if ((code1 | code2) == 0) {
 accept = 1;
 break;
 }
 else if (code1 & code2)
 break;
 else {
 int codeOut;
 float x, y;
 if (code1 != 0)
 codeOut = code1;
 else
 codeOut = code2;
 if (codeOut & TOP) {
 x = x1 + (x2 - x1) * (ymax - y1) / (y2 - y1);
 y = ymax;
 }
 else if (codeOut & BOTTOM) {
 x = x1 + (x2 - x1) * (ymin - y1) / (y2 - y1);
 y = ymin;
 }
 else if (codeOut & RIGHT) {
 y = y1 + (y2 - y1) * (xmax - x1) / (x2 - x1);
 x = xmax;
 }
 else { // LEFT
 y = y1 + (y2 - y1) * (xmin - x1) / (x2 - x1);
 x = xmin;
 }
 if (codeOut == code1) {
 x1 = x; y1 = y;
 code1 = computeCode(x1, y1);
 } else {
 x2 = x; y2 = y;
 code2 = computeCode(x2, y2);
 }
 }
 }
 // Draw clipping window
 glColor3f(1, 0, 0);
 glBegin(GL_LINE_LOOP);
 glVertex2i(xmin, ymin);
 glVertex2i(xmax, ymin);
 glVertex2i(xmax, ymax);
 glVertex2i(xmin, ymax);
 glEnd();
 // Draw clipped line
 if (accept) {
 glColor3f(0, 1, 0);
 glBegin(GL_LINES);
 glVertex2f(x1, y1);
 glVertex2f(x2, y2);
 glEnd();
 }
 glFlush();
}
void init2D() {
 glClearColor(1, 1, 1, 1);
 // NO GLU USED — ✔ 100% SAFE
 glMatrixMode(GL_PROJECTION);
 glLoadIdentity();
 glOrtho(0, 500, 0, 500, -1, 1); // SAFE replacement
}
int main(int argc, char **argv) {
 glutInit(&argc, argv);
 glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
 glutInitWindowSize(600, 600);
 glutCreateWindow("Cohen-Sutherland Line Clipping");
 init2D();
 glutDisplayFunc(display);
 glutMainLoop();
 return 0;
}


//cube



#include <GL/glut.h>
float angle = 0;
// 8 vertices of the cube
float v[8][3] = {
 {-1,-1,-1},
 { 1,-1,-1},
 { 1, 1,-1},
 {-1, 1,-1},
 {-1,-1, 1},
 { 1,-1, 1},
 { 1, 1, 1},
 {-1, 1, 1}
};
// Colors for each face
float c[6][3] = {
 {1,0,0},
 {0,1,0},
 {0,0,1},
 {1,1,0},
 {1,0,1},
 {0,1,1}
};
void drawFace(int a, int b, int c_, int d)
{
 glBegin(GL_QUADS);
 glVertex3fv(v[a]);
 glVertex3fv(v[b]);
 glVertex3fv(v[c_]);
 glVertex3fv(v[d]);
 glEnd();
}
void drawCube()
{
 glColor3fv(c[0]); drawFace(0, 1, 2, 3); // Back
 glColor3fv(c[1]); drawFace(4, 5, 6, 7); // Front
 glColor3fv(c[2]); drawFace(0, 1, 5, 4); // Bottom
 glColor3fv(c[3]); drawFace(3, 2, 6, 7); // Top
 glColor3fv(c[4]); drawFace(0, 3, 7, 4); // Left
 glColor3fv(c[5]); drawFace(1, 2, 6, 5); // Right
}
void display()
{
 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 glLoadIdentity();
 // Move cube slightly back
 glTranslatef(0, 0, -5);
 // Apply spin
 glRotatef(angle, 1, 1, 0);
 // Draw cube
 drawCube();
 glutSwapBuffers();
}
void spinCube()
{
 angle += 0.4;
 if (angle > 360)
 angle = angle - 360;
 glutPostRedisplay();
}
void init()
{
 glEnable(GL_DEPTH_TEST);
 glClearColor(1, 1, 1, 1);
 glMatrixMode(GL_PROJECTION);
 glLoadIdentity();
 // No gluPerspective — SAFE
 glOrtho(-3, 3, -3, 3, 1, 15);
 glMatrixMode(GL_MODELVIEW);
}
int main(int argc, char **argv)
{
 glutInit(&argc, argv);
 glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
 glutInitWindowSize(600, 600);
 glutCreateWindow("Color Cube – Spin");
 init();
 glutDisplayFunc(display);
 glutIdleFunc(spinCube);
 glutMainLoop();
 return 0;
}

